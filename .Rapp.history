plot(x, y, main="diffusion example", xlab="x position", ylab="y position")
Sim.DiffProc-package()
Sim.DiffProc
install Sim.DiffProc-package()
install Sim.DiffProc
plot(morley)
install rgl
sudo R CMD INSTALL rgl_0.81.tar.gz
fn = function(x, y) {#
    x^2 + y^2 - 10 * (cos(2 * pi * x) + cos(2 * pi * y)) + 20#
}#
a = 5#
x = seq(-a, a, 0.05)#
y = seq(-a, a, 0.05)#
z = outer(x, y, fn)#
persp(x, y, z)#
library(rgl)#
zorder = rank(z)#
persp3d(x, y, z, col = rainbow(as.integer(max(zorder)))[zorder])
library(scatterplot3d)#
scatterplot3d(iris$Petal.Width,iris$Sepal.Length,iris$Sepal.Width,pch=16,color=as.numeric(iris$Species))
sudo R CMD INSTALL rgl_0.81.tar.gz
library(scatterplot3d)#
scatterplot3d(iris$Petal.Width,iris$Sepal.Length,iris$Sepal.Width,pch=16,color=as.numeric(iris$Species))
fn = function(x, y) {#
    x^2 + y^2 - 10 * (cos(2 * pi * x) + cos(2 * pi * y)) + 20#
}#
a = 5#
x = seq(-a, a, 0.05)#
y = seq(-a, a, 0.05)#
z = outer(x, y, fn)#
persp(x, y, z)#
library(rgl)#
zorder = rank(z)#
persp3d(x, y, z, col = rainbow(as.integer(max(zorder)))[zorder])
library(scatterplot3d)#
scatterplot3d(iris$Petal.Width,iris$Sepal.Length,iris$Sepal.Width,pch=16,color=as.numeric(iris$Species))
data(volcano)
z <- 2 * volcano # Exaggerate the relief#
x <- 10 * (1:nrow(z)) # 10 meter spacing (S to N)#
y <- 10 * (1:ncol(z)) # 10 meter spacing (E to W)
zlim <- range(y)#
zlen <- zlim[2] - zlim[1] + 1#
colorlut <- terrain.colors(zlen) # height color lookup table#
col <- colorlut[ z-zlim[1]+1 ] # assign colors to heights
persp3d(x, y, z, color = col, aspect = c(1.5, 1, 0.6))
play3d(spin3d(axis = c(0, 0, 1), rpm = 6), duration = 10)
scatterplot3d(x=mtcars$wt,#
y=mtcars$disp,#
z=mtcars$mpg)
scatterplot3d(mtcars$wt,mtcars$disp,mtcars$mpg,#
pch=16, highlight.3d=TRUE, angle=20,#
xlab="Weight",ylab="Displacement",zlab="Fuel Economy (mpg)",#
type="h",#
main="Relationships between car specifications")
x<-rnorm(1000)#
plot(density(x))#
rug(x)
metals<-read.csv("metals.csv")#
plot(Ba~Cu,data=metals,xlim=c(0,100))#
rug(metals$Cu)#
rug(metals$Ba,side=2,col="red",ticksize=0.02)
n <- 10000#
x <- matrix(rnorm(n), ncol=2)#
y <- matrix(rnorm(n, mean=3, sd=1.5), ncol=2)#
smoothScatter(x,y)
n <- 5#
x <- matrix(rnorm(n), ncol=2)#
y <- matrix(rnorm(n, mean=0.3, sd=1.5), ncol=2)#
smoothScatter(x,y)
n <- 500#
x <- matrix(rnorm(n), ncol=2)#
y <- matrix(rnorm(n, mean=3, sd=1.5), ncol=2)#
smoothScatter(x,y)
n <- 500000#
x <- matrix(rnorm(n), ncol=2)#
y <- matrix(rnorm(n, mean=3, sd=1.5), ncol=2)#
smoothScatter(x,y)
n <- 2#
x <- matrix(rnorm(n), ncol=2)#
y <- matrix(rnorm(n, mean=3, sd=1.5), ncol=2)#
smoothScatter(x,y)
n <- rnorm(10)#
x <- matrix(rnorm(n), ncol=2)#
y <- matrix(rnorm(n, mean=3, sd=1.5), ncol=2)#
smoothScatter(x,y)
n <- rnorm(5)#
x <- matrix(rnorm(n), ncol=20)#
y <- matrix(rnorm(n, mean=3, sd=1.5), ncol=2)#
smoothScatter(x,y)
n <- rnorm(5)#
x <- matrix(rnorm(n), ncol=2)#
y <- matrix(rnorm(n, mean=2, sd=1), ncol=2)#
smoothScatter(x,y)
n <- rnorm(2)#
x <- matrix(rnorm(n), ncol=2)#
y <- matrix(rnorm(n, mean=2, sd=1), ncol=2)#
smoothScatter(x,y)
n <- 5000#
x <- matrix(rnorm(n), ncol=2)#
y <- matrix(rnorm(n, mean=2, sd=1), ncol=2)#
smoothScatter(x,y)
plot(cars$dist~cars$speed,#y~x，cars是R自带的数据#
main="Relationship between car distance & speed",#标题#
xlab = "Speed(miles per hour)",#x轴标题#
ylab = "Distance travelled (miles)",#Y轴标题#
xlim = c(0,30),#设置x轴的取值区间为0到30#
ylim = c(0,140),#设置y轴的取值区间为0到140#
xaxs = "i",#这里是设置x轴的风格，暂时没看明白有多大区别#
yaxs = "i",#
col = "red",设置颜色#
pch = 19)#pch指代点的形状，用数字表示，可查看帮助文档
plot(cars$dist~cars$speed,#y~x，cars是R自带的数据#
main="Relationship between car distance & speed",#标题#
xlab = "Speed(miles per hour)",#x轴标题#
ylab = "Distance travelled (miles)",#Y轴标题#
xlim = c(0,30),#设置x轴的取值区间为0到30#
ylim = c(0,140),#设置y轴的取值区间为0到140#
xaxs = "i",#这里是设置x轴的风格，暂时没看明白有多大区别#
yaxs = "i",#
col = "red",#设置颜色#
pch = 19)#pch指代点的形状，用数字表示，可查看帮助文档
x<-rnorm(1000)#
plot(density(x))#
rug(x)
x<-rnorm(1000)#
plot(density(x), main="Density Distribution Along the x axis with Sample Capacity of 1000", xlab="Displacement", ylab="Relative Density")#
rug(x)
install.packages("maps")
library(maps)
maps
library(mapdata)#
map("worldHires","Canada”, xlim=c(-141,-53), ylim=c(40,85), col="gray90”, fill=TRUE)
install.package("mapdata")
library(mapdata)#
map("worldHires","Canada”, xlim=c(-141,-53), ylim=c(40,85), col="gray90”, fill=TRUE)
library(maps)#
library(mapdata)#
library(maptools)  #for shapefiles#
library(scales)  #for transparency#
pcontorta <- readShapePoly("pinucont.shp")   #layer of data for species range#
samps <- read.csv("FieldSamples.csv")   #my data for sampling sites, contains a column of "lat" and a column of "lon" with GPS points in decimal degrees#
map("worldHires","Canada", xlim=c(-140,-110),ylim=c(48,64), col="gray90", fill=TRUE)  #plot the region of Canada I want#
map("worldHires","usa", xlim=c(-140,-110),ylim=c(48,64), col="gray95", fill=TRUE, add=TRUE)  #add the adjacent parts of the US; can't forget my homeland#
plot(pcontorta, add=TRUE, xlim=c(-140,-110),ylim=c(48,64), col=alpha("darkgreen", 0.6), border=FALSE)  #plot the species range#
points(samps$lon, samps$lat, pch=19, col="red", cex=0.5)  #plot my sample sites
library(mapproj)#
map(database= "world", ylim=c(45,90), xlim=c(-160,-50), col="grey80", fill=TRUE, projection="gilbert", orientation= c(90,0,225))#
lon <- c(-72, -66, -107, -154)  #fake longitude vector#
lat <- c(81.7, 64.6, 68.3, 60)  #fake latitude vector#
coord <- mapproject(lon, lat, proj="gilbert", orientation=c(90, 0, 225))  #convert points to projected lat/long#
points(coord, pch=20, cex=1.2, col="red")  #plot converted points
add.pie(z=c(east, west), x=lon, y=lat, radius=sqrt(tot), col=c(alpha(“orange”, 0.6), alpha(“blue”, 0.6)), labels=”")
library(RgoogleMaps)#
lat <- c(48,64) #define our map's ylim#
lon <- c(-140,-110) #define our map's xlim#
center = c(mean(lat), mean(lon))  #tell what point to center on#
zoom <- 5  #zoom: 1 = furthest out (entire globe), larger numbers = closer in#
terrmap <- GetMap(center=center, zoom=zoom, maptype= "terrain", destfile = "terrain.png") #lots of visual options, just like google maps: maptype = c("roadmap", "mobile", "satellite", "terrain", "hybrid", "mapmaker-roadmap", "mapmaker-hybrid")
samps$size <- "small"  #create a column indicating size of marker#
samps$col <- "red"   #create a column indicating color of marker#
samps$char <- ""   #normal Google Maps pinpoints will be drawn#
mymarkers <- cbind.data.frame(samps$lat, samps$lon, samps$size, samps$col, samps$char)   #create the data frame by binding my data columns of GPS coordinates with the newly created columns#
names(mymarkers) <- c("lat", "lon", "size", "col", "char")  #assign column headings#
lat <- c(48,60)  #now we are plotting the map#
lon <- c(-140,-110)#
terrain_close <- GetMap.bbox(lonR= range(lon), latR= range(lat), center= c(49.7, -121.05), destfile= "terrclose.png", markers= mymarkers, zoom=13, maptype="terrain")
x<-rnorm(1000)#
plot(density(x), main="Density Distribution Along the x axis with Sample Capacity of 1000", xlab="Displacement", ylab="Relative Density")
x<-rnorm(1000)#
plot(density(x), main="Density Distribution Along the x axis with Sample Capacity of 1000", xlab="Displacement", ylab="Relative Density"); rug(x)
x<-rnorm(1000)#
plot(density(x), main="Density Distribution Simulation Along the x axis with Sample Capacity of 1000", xlab="Displacement", ylab="Relative Density"); rug(x)
x<-rnorm(1000)#
plot(density(x), main="Density Distribution Simulation Along the x axis with Sample Capacity of 1000", xlab="Displacement, sample capacity of 1000", ylab="Relative Density"); rug(x)
x<-rnorm(1000)#
plot(density(x), main="Density Distribution Simulation Along the x axis", xlab="Displacement, sample capacity of 1000", ylab="Relative Density"); rug(x)
library(scatterplot3d)#
scatterplot3d(iris$Petal.Width,iris$Sepal.Length,iris$Sepal.Width,pch=16,color=as.numeric(iris$Species))
z <- seq(-10, 10, 0.01)      x <- cos(z)      y <- sin(z)      scatterplot3d(x, y, z, highlight.3d=TRUE, col.axis="blue",          col.grid="lightblue", main="scatterplot3d - 1", pch=20)
z <- rnorm(5)      x <- rnorm(z)      y <- rnorm(x)      scatterplot3d(x, y, z, highlight.3d=TRUE, col.axis="blue",          col.grid="lightblue", main="scatterplot3d - 1", pch=20)
z <- rnorm(5)      x <- rnorm(z)      y <- rnorm(x)      scatterplot3d(x, y, z, highlight.3d=TRUE, col.axis="black",          col.grid="gray", main="scatterplot3d - 1", pch=20)
z <- rnorm(5)      x <- rnorm(z)      y <- rnorm(x)      scatterplot3d(x, y, z, highlight.3d=FALSE, col.axis="black",          col.grid="gray", main="Three Dimensional Diffusion Simulation", xlab="Displacement, x", ylab="Displacement, y", zlab="Displacement, z", pch=2)
z <- rnorm(5)      x <- rnorm(z)      y <- rnorm(x)      scatterplot3d(x, y, z, highlight.3d=FALSE, col.axis="black",          col.grid="gray", main="Three Dimensional Diffusion Simulation", xlab="Displacement, x", ylab="Displacement, y", zlab="Displacement, z", pch=5)
z <- rnorm(5)      x <- rnorm(z)      y <- rnorm(x)      scatterplot3d(x, y, z, highlight.3d=FALSE, col.axis="black",          col.grid="gray", main="Three Dimensional Diffusion Simulation", xlab="Displacement, x", ylab="Displacement, y", zlab="Displacement, z", pch=1)
temp <- seq(-pi, 0, length = 50)      x <- c(rep(1, 50) %*% t(cos(temp)))      y <- c(cos(temp) %*% t(sin(temp)))      z <- c(sin(temp) %*% t(sin(temp)))      scatterplot3d(x, y, z, highlight.3d=TRUE,          col.axis="blue", col.grid="lightblue",          main="scatterplot3d - 2", pch=20)
library(scatterplot3d)
temp <- seq(-pi, 0, length = 50)      x <- c(rep(1, 50) %*% t(cos(temp)))      y <- c(cos(temp) %*% t(sin(temp)))      z <- c(sin(temp) %*% t(sin(temp)))      scatterplot3d(x, y, z, highlight.3d=TRUE,          col.axis="blue", col.grid="lightblue",          main="scatterplot3d - 2", pch=20)
temp <- seq(-pi, 0, length = 50)      x <- c(rep(1, 50) %*% t(cos(temp)))      y <- c(cos(temp) %*% t(sin(temp)));z <- 10 * c(sin(temp) %*% t(sin(temp)))      color <- rep("green", length(x))      temp <- seq(-10, 10, 0.01)      x <- c(x, cos(temp))      y <- c(y, sin(temp))      z <- c(z, temp)      color <- c(color, rep("red", length(temp)))      scatterplot3d(x, y, z, color, pch=20, zlim=c(-2, 10),          main="scatterplot3d - 3")
my.mat <- matrix(runif(25), nrow=5)      dimnames(my.mat) <- list(LETTERS[1:5], letters[11:15])      my.mat # the matrix we want to plot ...      s3d.dat <- data.frame(cols=as.vector(col(my.mat)),          rows=as.vector(row(my.mat)),          value=as.vector(my.mat))      scatterplot3d(s3d.dat, type="h", lwd=5, pch=" ",          x.ticklabs=colnames(my.mat), y.ticklabs=rownames(my.mat),          color=grey(25:1/40), main="scatterplot3d - 4")
x <- rnorm(50)
y <- rnorm(x^3)
plot(x, y)
my.mat <- matrix(runif(25), nrow=5)      dimnames(my.mat) <- list(LETTERS[1:5], letters[11:15])      my.mat # the matrix we want to plot ...      s3d.dat <- data.frame(cols=as.vector(col(my.mat)),          rows=as.vector(row(my.mat)),          value=as.vector(my.mat))      scatterplot3d(s3d.dat, type="h", lwd=5, pch=" ",          x.ticklabs=colnames(my.mat), y.ticklabs=rownames(my.mat),          color=grey(25:1/40), main="scatterplot3d - 4")
temp <- seq(-pi, 0, length = 50)      x <- c(rep(1, 50) %*% t(cos(temp)))      y <- c(cos(temp) %*% t(sin(temp)));z <- 10 * c(sin(temp) %*% t(sin(temp)))      color <- rep("green", length(x))      temp <- seq(-10, 10, 0.01)      x <- c(x, cos(temp))      y <- c(y, sin(temp))      z <- c(z, temp)      color <- c(color, rep("red", length(temp)))      scatterplot3d(x, y, z, color, pch=20, zlim=c(-2, 10),          main="scatterplot3d - 3")
library(ggplot)
install.packages(ggplot)
install.package(ggplot)
install.packages(ggplot2)
install.packages("ggplot")
install.packages("ggplot2")
library(ggplot2)
temp <- seq(-pi, 0, length = 50)      x <- c(rep(1, 50) %*% t(cos(temp)))      y <- c(cos(temp) %*% t(sin(temp)));z <- 10 * c(sin(temp) %*% t(sin(temp)))      color <- rep("green", length(x))      temp <- seq(-10, 10, 0.01)      x <- c(x, cos(temp))      y <- c(y, sin(temp))      z <- c(z, temp)      color <- c(color, rep("red", length(temp)))      scatterplot3d(x, y, z, color, pch=20, zlim=c(-2, 10),          main="scatterplot3d - 3")
library(scatterplot3d)
temp <- seq(-pi, 0, length = 50)      x <- c(rep(1, 50) %*% t(cos(temp)))      y <- c(cos(temp) %*% t(sin(temp)));z <- 10 * c(sin(temp) %*% t(sin(temp)))      color <- rep("green", length(x))      temp <- seq(-10, 10, 0.01)      x <- c(x, cos(temp))      y <- c(y, sin(temp))      z <- c(z, temp)      color <- c(color, rep("red", length(temp)))      scatterplot3d(x, y, z, color, pch=20, zlim=c(-2, 10),          main="scatterplot3d - 3")
temp <- seq(-pi, 0, length = 50)      x <- c(rep(1, 50) %*% t(cos(temp)))      y <- c(cos(temp) %*% t(sin(temp)))      z <- c(sin(temp) %*% t(sin(temp)))      scatterplot3d(x, y, z, highlight.3d=TRUE,          col.axis="blue", col.grid="lightblue",          main="scatterplot3d - 2", pch=20)
z <- seq(-10, 10, 0.01)      x <- cos(z)      y <- sin(z)      scatterplot3d(x, y, z, highlight.3d=TRUE, col.axis="blue",          col.grid="lightblue", main="scatterplot3d - 1", pch=20)
samps$size <- "small"  #create a column indicating size of marker#
samps$col <- "red"   #create a column indicating color of marker#
samps$char <- ""   #normal Google Maps pinpoints will be drawn#
mymarkers <- cbind.data.frame(samps$lat, samps$lon, samps$size, samps$col, samps$char)   #create the data frame by binding my data columns of GPS coordinates with the newly created columns#
names(mymarkers) <- c("lat", "lon", "size", "col", "char")  #assign column headings#
lat <- c(48,60)  #now we are plotting the map#
lon <- c(-140,-110)#
terrain_close <- GetMap.bbox(lonR= range(lon), latR= range(lat), center= c(49.7, -121.05), destfile= "terrclose.png", markers= mymarkers, zoom=13, maptype="terrain")
n <- 5000#
x <- matrix(rnorm(n), ncol=2)#
y <- matrix(rnorm(n, mean=2, sd=1), ncol=2)#
smoothScatter(x,y)
data(volcano)
z <- 2 * volcano # Exaggerate the relief#
x <- 10 * (1:nrow(z)) # 10 meter spacing (S to N)#
y <- 10 * (1:ncol(z)) # 10 meter spacing (E to W)
zlim <- range(y)#
zlen <- zlim[2] - zlim[1] + 1#
colorlut <- terrain.colors(zlen) # height color lookup table#
col <- colorlut[ z-zlim[1]+1 ] # assign colors to heights
persp3d(x, y, z, color = col, aspect = c(1.5, 1, 0.6))
library(persp3d)
install.pakcages("persp3d")
zlim <- range(y)#
zlen <- zlim[2] - zlim[1] + 1#
colorlut <- terrain.colors(zlen) # height color lookup table#
col <- colorlut[ z-zlim[1]+1 ] # assign colors to heights
qqnorm(resid(fm), main="residuals rakit plot")
scatterplot3d(mtcars$wt,mtcars$disp,mtcars$mpg,#
pch=16, highlight.3d=TRUE, angle=20,#
xlab="Weight",ylab="Displacement",zlab="Fuel Economy (mpg)",#
type="h",#
main="Relationships between car specifications")
x <- seq(-2,3,0.05)#x在区间[-2,3]之间，取值隔0.05取一个#
y <- seq(-1,7,0.05)#y在区间[-1,7]之间,取值隔0.05取一个#
f <- function(x,y)#实现函数#
  {#
    x^4-2*x^2*y-2*x*y+2*y^2+4.5*x-4*y+4#
  }#
z <- outer(x,y,f)#让x,y在函数f的关系下作外积运算，形成网格，这样才能绘出三维图形#
a <-  seq(0,100,10)#
for (i in a)#
{#
  persp(x,y,z,theta=i,phi=30,expand=0.7,col="blue")#这里让观看的角度每隔一定时间变一次，theta应该是水平方向#的，phi是竖直方向上的角度#
  Sys.sleep(3)#让R的运行暂停三秒#
}
x <- seq(-2,3,0.05)#x在区间[-2,3]之间，取值隔0.05取一个#
y <- seq(-1,7,0.05)#y在区间[-1,7]之间,取值隔0.05取一个#
f <- function(x,y)#实现函数#
  {#
    x^4-2*x^2*y-2*x*y+2*y^2+4.5*x-4*y+4#
  }#
z <- outer(x,y,f)#让x,y在函数f的关系下作外积运算，形成网格，这样才能绘出三维图形#
a <-  seq(0,100,10)#
for (i in a)#
{#
  persp(x,y,z,theta=i,phi=30,expand=0.7,col="blue")#这里让观看的角度每隔一定时间变一次，theta应该是水平方向#的，phi是竖直方向上的角度#
  Sys.sleep(0.5)#让R的运行暂停三秒#
}
library(animation)#
library(lattice)#
 saveGIF({#
    ani.options(interval=.1,#
                convert = shQuote('d:/program files/ImageMagick-6.7.6-Q16/convert.exe'))#
    for (i in seq(0,360,by=5)) {#
        p <- wireframe(volcano, shade = TRUE,#
                  aspect = c(61/87, 0.4),#
                  light.source = c(10,0,10),#
                  screen = list(z = i, x = -60)) #
    print(p)#
        }#
})
install.package("animation")
library(animation)#
library(lattice)#
 saveGIF({#
    ani.options(interval=.1,#
                convert = shQuote('d:/program files/ImageMagick-6.7.6-Q16/convert.exe'))#
    for (i in seq(0,360,by=5)) {#
        p <- wireframe(volcano, shade = TRUE,#
                  aspect = c(61/87, 0.4),#
                  light.source = c(10,0,10),#
                  screen = list(z = i, x = -60)) #
    print(p)#
        }#
})
install.packages("xlsx")
install.packages("gdata")
install.packages("forign")
install.packages("foreign")
diffraction <- read.xlsx("diffraction.xlsx", 1)
library(xlsx)
diffraction <- read.xlsx("diffraction.xlsx", 1)
diffraction <- read.xlsx("/Users/apple/Desktop/diffraction.xlsx", 1)
show(diffraction)
plot(diffraction)
plor(mtcars$wt, mtcars$mpg)
plot(mtcars$wt, mtcars$mpg)
library(ggplot2)
qplot(mtcars$wt, mtcars$mpg)
qplot(wt, mpg, data=mtcars)
plot(pressure$temperature, pressure$pressure, type="1")
plot(pressure$temperature, pressure$pressure, type="l")
plot(pressure$temperature, pressure$pressure, type="b")
plot(pressure$temperature, pressure$pressure, type="b", col="red")
qplot(pressure$temperature, pressure$pressure, geom="line")
qplot(pressure$temperature, pressure$pressure, geom=c("line", "point"))
barplot(mtcars$cyl)
table(mtcars$cyl)
table(diffraction)
barplot(table(mtcars$cyl))
qplot(BOD$Time, BOD$demand, geom="bar", stat="identity")
qplot(factor(BOD$Time), BOD$demand, geom="bar", stat="identity")
x <- rnorm(50)
y <- rnorm(x)
qplot(x, y)
library(qplot)
plot(x, y)
end
library(gcookbook)
install.library ("gcookbook")
install("gcookbook")
install.packages("gcookbook")
library("gcookbook")
upc <- subset(uspopchange, rank(Change)>40)
upc
ggplot(upc, aes(x=Abb, y=Change, fill=Region))+geom_bar(stat="identity")
library(ggplot)
install.packages(ggplot)
install.packages("ggplot")
install.packages("qplot")
install.packages("ggplot2")
ggplot(upc, aes(x=Abb, y=Change, fill=Region))+geom_bar(stat="identity")
library(ggplot2)
ggplot(upc, aes(x=Abb, y=Change, fill=Region))+geom_bar(stat="identity")
now we finished the initiallation and soon we will create a simply scatter plot with R; qplot(mtcars$wt, mtcars$mpg); #here we are to create a line graph with R; plot(pressure$temperature, pressure$pressure, type="1"); points(pressure$temperature, pressure$pressure); lines(pressure$temperature, pressure$pressure/2, col="red"); points(pressure$temperature, pressure$pressure/2, col="blue")
qplot(mtcars$wt, mtcars$mpg); plot(pressure$temperature, pressure$pressure, type="1"); points(pressure$temperature, pressure$pressure); lines(pressure$temperature, pressure$pressure/2, col="red"); points(pressure$temperature, pressure$pressure/2, col="blue")
qplot(mtcars$wt, mtcars$mpg); plot(pressure$temperature, pressure$pressure, type="l"); points(pressure$temperature, pressure$pressure); lines(pressure$temperature, pressure$pressure/2, col="red"); points(pressure$temperature, pressure$pressure/2, col="blue")
library(qplot)
library(ggplot2)
qplot(mtcars$wt, mtcars$mpg); plot(pressure$temperature, pressure$pressure, type="l"); points(pressure$temperature, pressure$pressure); lines(pressure$temperature, pressure$pressure/2, col="red"); points(pressure$temperature, pressure$pressure/2, col="blue")
exit
install.packages("RSNNS")
library(RSNNS)#
data(iris)
library("Rcpp")
iris = iris[sample(1:nrow(iris),length(1:nrow(iris))),1:ncol(iris)]
irisValues= iris[,1:4]
irisTargets = decodeClassLabels(iris[,5])
iris = splitForTrainingAndTest(irisValues, irisTargets, ratio=0.15)
iris = normTrainingAndTestSet(iris)
model = mlp(iris$inputsTrain, iris$targetsTrain, size=5, learnFunc="Quickprop", learnFuncParams=c(0.1, 2.0, 0.0001, 0.1),maxit=100, inputsTest=iris$inputsTest, targetsTest=iris$targetsTest)
predictions = predict(model,iris$inputsTest)
confusionMatrix(iris$targetsTest,predictions)
library(RSNNS)#
data(iris)
confusionMatrix(iris$targetsTest,predictions)
> install.packages("RSNNS")#
> library(RSNNS)#
> data(iris)#
> library("Rcpp")#
> iris = iris[sample(1:nrow(iris),length(1:nrow(iris))),1:ncol(iris)]#
> irisValues= iris[,1:4]#
> irisTargets = decodeClassLabels(iris[,5])#
> iris = splitForTrainingAndTest(irisValues, irisTargets, ratio=0.15)#
> iris = normTrainingAndTestSet(iris)#
> model = mlp(iris$inputsTrain, iris$targetsTrain, size=5, learnFunc="Quickprop", learnFuncParams=c(0.1, 2.0, 0.0001, 0.1),maxit=100, inputsTest=iris$inputsTest, targetsTest=iris$targetsTest)#
> predictions = predict(model,iris$inputsTest)#
> confusionMatrix(iris$targetsTest,predictions)
install.packages("RSNNS");#
library(RSNNS);#
data(iris);#
library("Rcpp");#
iris = iris[sample(1:nrow(iris),length(1:nrow(iris))),1:ncol(iris)];#
irisValues= iris[,1:4];#
irisTargets = decodeClassLabels(iris[,5]);#
iris = splitForTrainingAndTest(irisValues, irisTargets, ratio=0.15);#
iris = normTrainingAndTestSet(iris);#
model = mlp(iris$inputsTrain, iris$targetsTrain, size=5, learnFunc="Quickprop", learnFuncParams=c(0.1, 2.0, 0.0001, 0.1),maxit=100, inputsTest=iris$inputsTest, targetsTest=iris$targetsTest);#
predictions = predict(model,iris$inputsTest);#
confusionMatrix(iris$targetsTest,predictions);
install.packages("RSNNS");#
library(RSNNS);#
data(iris);#
library("Rcpp");#
iris = iris[sample(1:nrow(iris),length(1:nrow(iris))),1:ncol(iris)];#
irisValues= iris[,1:4];#
irisTargets = decodeClassLabels(iris[,5]);#
iris = splitForTrainingAndTest(irisValues, irisTargets, ratio=0.15);#
iris = normTrainingAndTestSet(iris);#
model = mlp(iris$inputsTrain, iris$targetsTrain,size=5,learnFunc="Quickprop",learnFuncParams=c(0.1, 2.0, 0.0001, 0.1),maxit=100, inputsTest=iris$inputsTest,targetsTest=iris$targetsTest);#
predictions = predict(model,iris$inputsTest);#
confusionMatrix(iris$targetsTest,predictions);
library(animation)
install.packages("rgl")
demo(rgl_animation )
demo()
demo(persp)
demo()
demo(image)
demo(graphic capablities)
demo(graphics capablities)
demo(graphics capabilities)
demo(graphics)
demo(Japanese)
demo(plotmath)
setwd("/Users/apple/projects/R")
list: list is one of the most complex data type in R. a list is the set of some components with a specific coordination. List allows you to integrate many components under one component, even it might not be relevant, for example, the components in a list can be some vectors, some matrixes or data frames, even combination of other lists.
g <- "first list"
h <- c(24, 25, 95, 81)
j <- matrix(1:10, nrow=5)
k <- c("one", "two", "three")
mylist <- list(title=g, ages=h,j,k)
create the list
mylist
mylist[[2]]
mylist[["ages"]]
the notation [[2]] here means 'output the second component'
data input
first, use keyboard
second, use txt
third use excel(csv)
graphic sketch
attach(mtcars)
plot(wt, mpg)
abline(lm(mpg-wt))
abline(lm(mpg~wt))
title("regression")
detach(mtcars)
pdf("graph.pdf")
attach(mtcars)
plot(wt, mpg)
abline(lm(mpg~wt))
title("regression")
detach(mtcars)
dev.off()
hist(wt, mpg)
attach(mtcars)
hist(wt, mpg)
dose <- c(20, 30, 40, 45, 60)
drugA <- c(16, 20, 27, 40, 60)
drugB <- c(15, 18, 25, 31, 40)
library(ggplot2)
detach(mtcars)
qplot(dose, drugA, drugB)
qplot(dose, drugA, type="b")
plot(dose, drugA, type="b")
qplot(dose, drugA, type="c")
plot(dose, drugA, type="c")
plot(dose, drugA, type="d")
plot(dose, drugA, type="a")
plot(dose, drugA, type="b")
opar <- par(no.readonly=TRUE)
par(lty=2, pch=17)
plot(does, drugA, type="b")
plot(dose, drugA, type="b")
par(opar)
update.package
update.packages
update.packages()
update.library()
update.libraries()
n <- 40
colour <- rainbow(n)
pie(rep(1, n), labels=colours, col=colours)
pie(rep(1, n), labels=colour, col=colour)
pie(rep(1, n), labels=colour, col=colour, bg=#f1f1f1)
end
pie
pie(rep(1, n), labels=colour, col=colour, bg="#f1f1f1")
pie(rep(1, n), labels=colour, col=colour, bg="#fff")
pie(rep(1, n), labels=colour, col=colour, bg="#f0f0f0")
pie(rep(1, n), labels=colour, col=colour, bg="#000001")
